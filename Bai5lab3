#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <cctype>
#include <cmath>
#include <sstream>
using namespace std;

class InfixCalculator {
private:
    int precedence(char op) {
        if (op == '^') return 3;
        if (op == '*' || op == '/') return 2;
        if (op == '+' || op == '-') return 1;
        return 0;
    }

    bool isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
    }

    int applyOperator(int a, int b, char op) {
        switch(op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': 
                if (b == 0) throw runtime_error("Loi: chia cho 0");
                return a / b;
            case '^': return (int)pow(a, b);
            default: return 0;
        }
    }

public:
    vector<string> tokenize(const string& expression) {
        vector<string> tokens;
        string currentToken = "";
        
        for (char c : expression) {
            if (c == ' ') {
                if (!currentToken.empty()) {
                    tokens.push_back(currentToken);
                    currentToken = "";
                }
            }
            else if (isOperator(c) || c == '(' || c == ')') {
                if (!currentToken.empty()) {
                    tokens.push_back(currentToken);
                    currentToken = "";
                }
                tokens.push_back(string(1, c));
            }
            else {
                currentToken += c;
            }
        }
        
        if (!currentToken.empty()) {
            tokens.push_back(currentToken);
        }
        
        return tokens;
    }

    vector<string> infixToPostfix(const vector<string>& tokens) {
        vector<string> output;
        stack<string> operatorStack;
        
        for (const string& token : tokens) {
            if (isdigit(token[0]) || (token.length() > 1 && isdigit(token[1]))) {
                output.push_back(token);
            }
            else if (isOperator(token[0])) {
                while (!operatorStack.empty() && 
                       isOperator(operatorStack.top()[0]) &&
                       precedence(operatorStack.top()[0]) >= precedence(token[0])) {
                    output.push_back(operatorStack.top());
                    operatorStack.pop();
                }
                operatorStack.push(token);
            }
            else if (token == "(") {
                operatorStack.push(token);
            }
            else if (token == ")") {
                while (!operatorStack.empty() && operatorStack.top() != "(") {
                    output.push_back(operatorStack.top());
                    operatorStack.pop();
                }
                if (!operatorStack.empty()) {
                    operatorStack.pop();
                }
            }
        }
        
        while (!operatorStack.empty()) {
            output.push_back(operatorStack.top());
            operatorStack.pop();
        }
        
        return output;
    }

    int evaluatePostfix(const vector<string>& postfix) {
        stack<int> valueStack;
        
        for (const string& token : postfix) {
            if (isdigit(token[0]) || (token.length() > 1 && isdigit(token[1]))) {
                valueStack.push(stoi(token));
            }
            else if (isOperator(token[0])) {
                int b = valueStack.top(); valueStack.pop();
                int a = valueStack.top(); valueStack.pop();
                int result = applyOperator(a, b, token[0]);
                valueStack.push(result);
            }
        }
        
        return valueStack.top();
    }

    void processExpression(const string& expression) {
        try {
            // Bước 1: Tách token
            vector<string> tokens = tokenize(expression);
            
            // Bước 2: Chuyển sang hậu tố
            vector<string> postfix = infixToPostfix(tokens);
            
            // Bước 3: Hiển thị kết quả hậu tố
            cout << "Bieu thuc hau to: ";
            for (size_t i = 0; i < postfix.size(); ++i) {
                cout << postfix[i];
                if (i < postfix.size() - 1) cout << " ";
            }
            cout << endl;
            
            // Bước 4: Tính giá trị
            int result = evaluatePostfix(postfix);
            cout << "Gia tri: " << result << endl;
            
        } catch (const exception& e) {
            cout << "Loi: " << e.what() << endl;
        }
    }
};

int main() {
    InfixCalculator calculator;
    string expression;
    
    cout << "Nhap bieu thuc trung to: ";
    getline(cin, expression);
    
    calculator.processExpression(expression);
    
    return 0;
}
